// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.7.6;

import "contracts/protocol/futures/RewardsFutureVault.sol";

/**
 * @title Main future abstraction contract for the rate futures
 * @notice Handles the rates future mecanisms
 * @dev Basis of all mecanisms for futures (registrations, period switch)
 */
abstract contract RateFutureVault is RewardsFutureVault {
    using SafeMathUpgradeable for uint256;

    mapping(uint256 => uint256) internal IBTRates;

    /**
     * @notice Intializer
     * @param _controller the address of the controller
     * @param _ibt the address of the corresponding IBT
     * @param _periodDuration the length of the period (in days)
     * @param _platformName the name of the platform and tools
     * @param _admin the address of the ACR admin
     */
    function initialize(
        IController _controller,
        IERC20 _ibt,
        uint256 _periodDuration,
        string memory _platformName,
        address _admin
    ) public virtual override initializer {
        super.initialize(_controller, _ibt, _periodDuration, _platformName, _admin);
        IBTRates[getCurrentPeriodIndex()] = getIBTRate();
    }

    /**
     * @notice Start a new period
     * @dev needs corresponding permissions for sender
     */
    function startNewPeriod() public virtual override nextPeriodAvailable periodsActive nonReentrant {
        require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
        _switchPeriod();
        IBTRates[getCurrentPeriodIndex()] = getIBTRate();
    }

    function convertIBTToUnderlying(uint256 _amount) public view virtual override returns (uint256) {
        return _convertIBTToUnderlyingAtRate(_amount, getIBTRate());
    }

    function _convertIBTToUnderlyingAtRate(uint256 _amount, uint256 _rate) internal view virtual returns (uint256) {
        return (_amount.mul(_rate) / IBT_UNIT);
    }

    function convertUnderlyingtoIBT(uint256 _amount) public view virtual override returns (uint256) {
        return _convertUnderlyingtoIBTAtRate(_amount, getIBTRate());
    }

    function _convertUnderlyingtoIBTAtRate(uint256 _amount, uint256 _rate) internal view virtual returns (uint256) {
        return _amount.mul(IBT_UNIT).div(_rate);
    }

    /**
     * @notice Getter for user IBT amount that is unlockable
     * @param _user user to unlock the IBT from
     * @return the amount of IBT the user can unlock
     */
    function getUnlockableFunds(address _user) public view virtual override returns (uint256) {
        return convertUnderlyingtoIBT(super.getUnlockableFunds(_user));
    }

    /**
     * @notice Getter for the yield currently generated by one pt for the current period
     * @return the amount of yield (in IBT) generated during the current period
     */
    function getUnrealisedYieldPerPT() public view virtual override returns (uint256) {
        uint256 currRate = getIBTRate();
        uint256 currPeriodStartRate = IBTRates[getCurrentPeriodIndex()];
        if (currRate == currPeriodStartRate) return 0;
        uint256 amountOfIBTsAtStart = _convertUnderlyingtoIBTAtRate(IBT_UNIT, currPeriodStartRate);
        uint256 amountOfIBTsNow = _convertUnderlyingtoIBTAtRate(IBT_UNIT, currRate);
        return amountOfIBTsAtStart.sub(amountOfIBTsNow);
    }

    /**
     * @notice Getter for the rate of the IBT
     * @return the uint256 rate, IBT x rate must be equal to the quantity of underlying tokens
     */
    function getIBTRate() public view virtual returns (uint256);

    /**
     * @notice Getter for the number of pt that can be minted for an amoumt deposited now
     * @param _amount the amount to of IBT to deposit
     * @return the number of pt that can be minted for that amount
     */
    function getPTPerAmountDeposited(uint256 _amount) public view virtual override returns (uint256) {
        return _convertIBTToUnderlyingAtRate(_amount, IBTRates[getCurrentPeriodIndex()]);
    }
}
