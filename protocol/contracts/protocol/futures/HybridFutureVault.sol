// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.7.6;

import "contracts/protocol/futures/RateFutureVault.sol";

/**
 * @title Main future abstraction contract for the hybrid futures
 * @notice Handles the rates and scaled amounts for future mecanisms
 * @dev Basis of all mecanisms for futures (registrations, period switch)
 */
abstract contract HybridFutureVault is RateFutureVault {
    using SafeMathUpgradeable for uint256;

    mapping(uint256 => uint256) internal scaledTotals; // scaled IBT amount

    /**
     * @notice Deposit funds into ongoing period
     * @param _user user adress
     * @param _amount amount of ibt to deposit
     * @dev part of the amount deposited will be used to buy back the yield already generated proportionally to the amount deposited
     */
    function deposit(address _user, uint256 _amount) external virtual override periodsActive depositsEnabled onlyController {
        require((_amount > 0) && (_amount <= ibt.balanceOf(_user)), "HybridFutureVault: ERR_AMOUNT");
        _deposit(_user, _amount);
        uint256 currScaledTotals = scaledTotals[getCurrentPeriodIndex()];
        if (currScaledTotals == 0) {
            require(_amount > IBT_UNIT, "HybridFutureVault: ERR_FUTURE_INIT"); // require 1 ibt unit as first deposit to avoid maths scaling issue
            scaledTotals[getCurrentPeriodIndex()] = _amount;
        } else {
            scaledTotals[getCurrentPeriodIndex()] = currScaledTotals.add(
                convertUnderlyingtoIBT(getPTPerAmountDeposited(_amount))
            );
        }
        emit FundsDeposited(_user, _amount);
    }

    /**
     * @notice Internal function for withdrawing funds corresponding to the pt holding of an address
     * @param _user user adress
     * @param _amount amount of funds to unlock
     * @dev handle the logic of withdraw but does not burn fyts
     */
    function _withdraw(address _user, uint256 _amount) internal virtual override {
        uint256 scaledAmountToRemove = convertUnderlyingtoIBT(getPTPerAmountDeposited(_amount));
        super._withdraw(_user, _amount);
        uint256 currentPeriodIndex = getCurrentPeriodIndex();
        scaledTotals[currentPeriodIndex] = scaledTotals[currentPeriodIndex].sub(scaledAmountToRemove);
    }

    /**
     * @notice Start a new period
     * @dev needs corresponding permissions for sender
     */
    function startNewPeriod() public virtual override nextPeriodAvailable periodsActive nonReentrant {
        require(hasRole(CONTROLLER_ROLE, msg.sender), "ERR_CALLER");
        _switchPeriod();
        // Rate
        IBTRates[getCurrentPeriodIndex()] = getIBTRate();
        // Stream
        scaledTotals[getCurrentPeriodIndex()] = ibt.balanceOf(address(this));
    }

    /**
     * @notice Getter for the yield currently generated by one pt for the current period
     * @return the amount of yield (in IBT) generated during the current period
     */
    function getUnrealisedYieldPerPT() public view override returns (uint256) {
        uint256 totalUnderlyingAtStart = totalUnderlyingDeposited;
        if (totalUnderlyingAtStart == 0) return 0;
        uint256 totalUnderlyingNow = convertIBTToUnderlying(ibt.balanceOf(address(this)));
        uint256 yieldForAllPT = convertUnderlyingtoIBT(totalUnderlyingNow.sub(totalUnderlyingAtStart));
        return yieldForAllPT.mul(IBT_UNIT).div(totalUnderlyingAtStart);
    }

    /**
     * @notice Getter for the number of pt that can be minted for an amoumt deposited now
     * @param _amount the amount to of IBT to deposit
     * @return the number of pt that can be minted for that amount
     */
    function getPTPerAmountDeposited(uint256 _amount) public view override returns (uint256) {
        uint256 scaledAmount = APWineMaths.getScaledInput(
            _amount,
            scaledTotals[getCurrentPeriodIndex()],
            ibt.balanceOf(address(this))
        );
        return _convertIBTToUnderlyingAtRate(scaledAmount, IBTRates[getCurrentPeriodIndex()]);
    }
}
